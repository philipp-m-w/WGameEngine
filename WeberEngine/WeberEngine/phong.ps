/////////////
// GLOBALS //
/////////////
Texture2D shaderTexture;
SamplerState SampleType;

cbuffer MaterialBuffer
{
	float n; //phong exponent of the material
	float3 k_s; // the specular material parameter in RGB
};


//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
	float3 world_pos : TEXCOORD2;
	//world position of the pixel
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
    float3 normal : NORMAL;
    float3 viewDirection : TEXCOORD1;

	float3 lightPos1 : TEXCOORD3;
	float3 lightPos2 : TEXCOORD4;
	float3 lightPos3 : TEXCOORD5;
	float3 lightPos4 : TEXCOORD6;
};


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 PhongPixelShader(PixelInputType input) : SV_TARGET
{
		
	float4 outputColor = float4(0.0f, 0.0f, 0.0f, 0.0f);	
	float4 diff_and_spec_color = float4(0.0f, 0.0f, 0.0f, 0.0f);	
	float spec_normalization = (n + 2.0f) / (6.2831853f);

	float4 textureColor = shaderTexture.Sample(SampleType, input.tex);
	float3 k_d = textureColor.xyz;

	float3 V = normalize(input.viewDirection);

	float3 in_pos = input.world_pos;
	//float3 in_pos = input.position.xyz;

	
	float3 L1 = normalize(input.lightPos1 - in_pos);
	float3 R1 = normalize(reflect(L1, input.normal));
	float3 multiplicator1 = k_d * max(0.0f, dot(L1, input.normal)) + k_s * spec_normalization * pow(max(0.0f, dot(R1, V)), n);
	float divisor1 = saturate(dot((in_pos - input.lightPos1), (in_pos - input.lightPos1)));
	//diff_and_spec_color.rgb += (multiplicator1 / divisor1);
	diff_and_spec_color.rgb += multiplicator1;
	
	//dasselbe für die anderen Lichter auch machen !!

	
	float3 L2 = normalize(input.lightPos2 - in_pos);
	float3 R2 = normalize(reflect(L2, input.normal));
	float3 multiplicator2 = k_d * max(0.0f, dot(L2, input.normal)) + k_s * spec_normalization *  pow(max(0.0f, dot(R2, V)), n);
	float divisor2 = saturate(dot((in_pos - input.lightPos2), (in_pos - input.lightPos2)));
	//diff_and_spec_color.rgb += (multiplicator2 / divisor2);
	diff_and_spec_color.rgb += multiplicator2;
	
	
	float3 L3 = normalize(input.lightPos3 - in_pos);
	float3 R3 = normalize(reflect(L3, input.normal));
	float3 multiplicator3 = k_d * max(0.0f, dot(L3, input.normal)) + k_s * spec_normalization * pow(max(0.0f, dot(R3, V)), n);
	float divisor3 = saturate(dot((in_pos - input.lightPos3), (in_pos - input.lightPos3)));
	//diff_and_spec_color.rgb += (multiplicator3 / divisor3);
	diff_and_spec_color.rgb += multiplicator3;
	
	
	float3 L4 = normalize(input.lightPos4 - in_pos);
	float3 R4 = normalize(reflect(L4, input.normal));
	float3 multiplicator4 = k_d * max(0.0f, dot(L4, input.normal)) + k_s * spec_normalization * pow(max(0.0f, dot(R4, V)), n);
	float divisor4 = saturate(dot((in_pos - input.lightPos4), (in_pos - input.lightPos4)));
	//diff_and_spec_color.rgb += (multiplicator4 / divisor4);
	diff_and_spec_color.rgb += multiplicator4;
	
	outputColor = float4(0.1f, 0.1f, 0.1f, 1.0f) + diff_and_spec_color;

	return saturate(outputColor);
		

	//TEST
	//float4 textureColor = shaderTexture.Sample(SampleType, input.tex);
	//return textureColor;
}