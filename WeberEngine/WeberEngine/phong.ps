/////////////
// GLOBALS //
/////////////
Texture2D shaderTexture;
SamplerState SampleType;

cbuffer LightBuffer
{
	int lightCount;    
	float3 padding;

	float4 lightColor1;
	//Position und Richtung des Lichts für PhongShading
	float3 lightDirection1;
	float3 lightPosition1;	

	float4 lightColor2;
	float3 lightDirection2;
	float3 lightPosition2;

	float4 lightColor3;
	float3 lightDirection3;
	float3 lightPosition3;

	float4 lightColor4;
	float3 lightDirection4;
	float3 lightPosition4;

	float4 lightColor5;
	float3 lightDirection5;
	float3 lightPosition5;

	float4 lightColor6;
	float3 lightDirection6;
	float3 lightPosition6;

	float4 lightColor7;
	float3 lightDirection7;
	float3 lightPosition7;

	float4 lightColor8;
	float3 lightDirection8;
	float3 lightPosition8;

	float4 lightColor9;
	float3 lightDirection9;
	float3 lightPosition9;

	float4 lightColor10;
	float3 lightDirection10;
	float3 lightPosition10;
};

cbuffer MaterialBuffer
{
	float n; //phong exponent of the material
	float3 k_s; // the specular material parameter in RGB
};


//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
	float3 cam_world_pos : TEXCOORD2;
	//world position of the pixel
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
    float3 normal : NORMAL;
    float3 viewDirection : TEXCOORD1;
};


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 PhongPixelShader(PixelInputType input) : SV_TARGET
{
		
	float4 outputColor = float4(0.0f, 0.0f, 0.0f, 0.0f);

	//lege array fuer lichter an:
	float4 lightColors[10] = {lightColor1, lightColor2, lightColor3, lightColor4, lightColor5, lightColor6, lightColor7, lightColor8, lightColor9, lightColor10};
	float3 lightDirections[10] = {lightDirection1, lightDirection2, lightDirection3, lightDirection4, lightDirection5, lightDirection6, lightDirection7, lightDirection8, lightDirection9, lightDirection10};
	float3 lightPositions[10] = {lightPosition1, lightPosition2, lightPosition3, lightPosition4, lightPosition5, lightPosition6, lightPosition7, lightPosition8, lightPosition9, lightPosition10};

	float4 textureColor = shaderTexture.Sample(SampleType, input.tex);
	float3 k_d = textureColor.xyz;

	float3 V = normalize(input.cam_world_pos - input.position.xyz);
	//TODO: reflect??
	float3 R = normalize(reflect(V, input.normal));

	float3 in_pos = input.position.xyz;

	[loop]
	for (int i = 0; i < lightCount; i++)
	{
		float3 L = normalize(lightPositions[i] - in_pos);
		float3 multiplicator = k_d * max(0.0f, dot(L, input.normal)) + k_s * pow(max(0.0f, dot(R, L)), n);
		float divisor = saturate(dot((in_pos - lightPositions[i]), (in_pos - lightPositions[i])));
		outputColor.rgb += (multiplicator * (lightColors[i].rgb / divisor), 1.0f);
	}
	if (lightCount > 0) 
	{
		outputColor.rgb = (outputColor.rgb / lightCount);
	} else {
		outputColor.rgb = k_d;
	}

	return saturate(outputColor);
		

	//TEST
	//float4 textureColor = shaderTexture.Sample(SampleType, input.tex);
	//return textureColor;
}